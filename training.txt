CAUTION - EXTERNAL EMAIL
Full-Stack E-Commerce Store: Learning Guide
üéØ What You'll Build
A complete online store with:
‚Ä¢	Modern React frontend (Vite, React Router, Context API, React Query)
‚Ä¢	.NET 8 Web API backend (Clean Architecture, Entity Framework Core)
‚Ä¢	MySQL database with proper relationships
‚Ä¢	Azure deployment (App Service, Azure Database for MySQL)
________________________________________
üìö Phase 1: Backend with .NET 8
Step 1.1: Create the .NET Web API Project
# Install .NET 8 SDK first from https://dotnet.microsoft.com/download

# Create solution and projects
dotnet new sln -n OnlineStore
dotnet new webapi -n OnlineStore.API
dotnet new classlib -n OnlineStore.Core
dotnet new classlib -n OnlineStore.Infrastructure

# Add projects to solution
dotnet sln add OnlineStore.API/OnlineStore.API.csproj
dotnet sln add OnlineStore.Core/OnlineStore.Core.csproj
dotnet sln add OnlineStore.Infrastructure/OnlineStore.Infrastructure.csproj

# Add project references
cd OnlineStore.API
dotnet add reference ../OnlineStore.Core/OnlineStore.Core.csproj
dotnet add reference ../OnlineStore.Infrastructure/OnlineStore.Infrastructure.csproj

cd ../OnlineStore.Infrastructure
dotnet add reference ../OnlineStore.Core/OnlineStore.Core.csproj
Step 1.2: Install Required NuGet Packages
cd ../OnlineStore.API
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package Swashbuckle.AspNetCore

cd ../OnlineStore.Infrastructure
dotnet add package Pomelo.EntityFrameworkCore.MySql
dotnet add package Microsoft.EntityFrameworkCore
Step 1.3: Create Domain Models (OnlineStore.Core)
OnlineStore.Core/Entities/Product.cs
namespace OnlineStore.Core.Entities;

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public string ImageUrl { get; set; } = string.Empty;
    public int Stock { get; set; }
    public int CategoryId { get; set; }
    public Category Category { get; set; } = null!;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}
OnlineStore.Core/Entities/Category.cs
namespace OnlineStore.Core.Entities;

public class Category
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public ICollection<Product> Products { get; set; } = new List<Product>();
}
OnlineStore.Core/Entities/Order.cs
namespace OnlineStore.Core.Entities;

public class Order
{
    public int Id { get; set; }
    public string CustomerName { get; set; } = string.Empty;
    public string CustomerEmail { get; set; } = string.Empty;
    public decimal TotalAmount { get; set; }
    public OrderStatus Status { get; set; } = OrderStatus.Pending;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public ICollection<OrderItem> OrderItems { get; set; } = new List<OrderItem>();
}

public enum OrderStatus
{
    Pending,
    Processing,
    Shipped,
    Delivered,
    Cancelled
}
OnlineStore.Core/Entities/OrderItem.cs
namespace OnlineStore.Core.Entities;

public class OrderItem
{
    public int Id { get; set; }
    public int OrderId { get; set; }
    public Order Order { get; set; } = null!;
    public int ProductId { get; set; }
    public Product Product { get; set; } = null!;
    public int Quantity { get; set; }
    public decimal Price { get; set; }
}
Step 1.4: Create Repository Interfaces (OnlineStore.Core)
OnlineStore.Core/Interfaces/IRepository.cs
namespace OnlineStore.Core.Interfaces;

public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(int id);
    Task<IEnumerable<T>> GetAllAsync();
    Task<T> AddAsync(T entity);
    Task UpdateAsync(T entity);
    Task DeleteAsync(int id);
}
OnlineStore.Core/Interfaces/IProductRepository.cs
using OnlineStore.Core.Entities;

namespace OnlineStore.Core.Interfaces;

public interface IProductRepository : IRepository<Product>
{
    Task<IEnumerable<Product>> GetByCategoryAsync(int categoryId);
    Task<IEnumerable<Product>> SearchAsync(string searchTerm);
}
Step 1.5: Create DbContext (OnlineStore.Infrastructure)
OnlineStore.Infrastructure/Data/StoreDbContext.cs
using Microsoft.EntityFrameworkCore;
using OnlineStore.Core.Entities;

namespace OnlineStore.Infrastructure.Data;

public class StoreDbContext : DbContext
{
    public StoreDbContext(DbContextOptions<StoreDbContext> options) : base(options) { }

    public DbSet<Product> Products { get; set; }
    public DbSet<Category> Categories { get; set; }
    public DbSet<Order> Orders { get; set; }
    public DbSet<OrderItem> OrderItems { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Product>(entity =>
        {
            entity.Property(p => p.Price).HasPrecision(18, 2);
            entity.HasOne(p => p.Category)
                  .WithMany(c => c.Products)
                  .HasForeignKey(p => p.CategoryId);
        });

        modelBuilder.Entity<Order>(entity =>
        {
            entity.Property(o => o.TotalAmount).HasPrecision(18, 2);
        });

        modelBuilder.Entity<OrderItem>(entity =>
        {
            entity.Property(oi => oi.Price).HasPrecision(18, 2);
            entity.HasOne(oi => oi.Order)
                  .WithMany(o => o.OrderItems)
                  .HasForeignKey(oi => oi.OrderId);
        });

        // Seed data
        modelBuilder.Entity<Category>().HasData(
            new Category { Id = 1, Name = "Electronics" },
            new Category { Id = 2, Name = "Clothing" },
            new Category { Id = 3, Name = "Books" }
        );

        modelBuilder.Entity<Product>().HasData(
            new Product { Id = 1, Name = "Laptop", Description = "High-performance laptop", Price = 999.99m, Stock = 10, CategoryId = 1, ImageUrl = "https://via.placeholder.com/300" },
            new Product { Id = 2, Name = "T-Shirt", Description = "Cotton t-shirt", Price = 19.99m, Stock = 50, CategoryId = 2, ImageUrl = "https://via.placeholder.com/300" },
            new Product { Id = 3, Name = "Novel", Description = "Bestselling novel", Price = 14.99m, Stock = 30, CategoryId = 3, ImageUrl = "https://via.placeholder.com/300" }
        );
    }
}
Step 1.6: Implement Repositories (OnlineStore.Infrastructure)
OnlineStore.Infrastructure/Repositories/Repository.cs
using Microsoft.EntityFrameworkCore;
using OnlineStore.Core.Interfaces;
using OnlineStore.Infrastructure.Data;

namespace OnlineStore.Infrastructure.Repositories;

public class Repository<T> : IRepository<T> where T : class
{
    protected readonly StoreDbContext _context;
    protected readonly DbSet<T> _dbSet;

    public Repository(StoreDbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }

    public async Task<T?> GetByIdAsync(int id) => await _dbSet.FindAsync(id);
    
    public async Task<IEnumerable<T>> GetAllAsync() => await _dbSet.ToListAsync();
    
    public async Task<T> AddAsync(T entity)
    {
        await _dbSet.AddAsync(entity);
        await _context.SaveChangesAsync();
        return entity;
    }
    
    public async Task UpdateAsync(T entity)
    {
        _dbSet.Update(entity);
        await _context.SaveChangesAsync();
    }
    
    public async Task DeleteAsync(int id)
    {
        var entity = await GetByIdAsync(id);
        if (entity != null)
        {
            _dbSet.Remove(entity);
            await _context.SaveChangesAsync();
        }
    }
}
OnlineStore.Infrastructure/Repositories/ProductRepository.cs
using Microsoft.EntityFrameworkCore;
using OnlineStore.Core.Entities;
using OnlineStore.Core.Interfaces;
using OnlineStore.Infrastructure.Data;

namespace OnlineStore.Infrastructure.Repositories;

public class ProductRepository : Repository<Product>, IProductRepository
{
    public ProductRepository(StoreDbContext context) : base(context) { }

    public async Task<IEnumerable<Product>> GetByCategoryAsync(int categoryId)
    {
        return await _dbSet
            .Include(p => p.Category)
            .Where(p => p.CategoryId == categoryId)
            .ToListAsync();
    }

    public async Task<IEnumerable<Product>> SearchAsync(string searchTerm)
    {
        return await _dbSet
            .Include(p => p.Category)
            .Where(p => p.Name.Contains(searchTerm) || p.Description.Contains(searchTerm))
            .ToListAsync();
    }
}
Step 1.7: Create API Controllers (OnlineStore.API)
OnlineStore.API/Controllers/ProductsController.cs
using Microsoft.AspNetCore.Mvc;
using OnlineStore.Core.Entities;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductRepository _productRepository;

    public ProductsController(IProductRepository productRepository)
    {
        _productRepository = productRepository;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Product>>> GetProducts()
    {
        var products = await _productRepository.GetAllAsync();
        return Ok(products);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<Product>> GetProduct(int id)
    {
        var product = await _productRepository.GetByIdAsync(id);
        if (product == null) return NotFound();
        return Ok(product);
    }

    [HttpGet("category/{categoryId}")]
    public async Task<ActionResult<IEnumerable<Product>>> GetByCategory(int categoryId)
    {
        var products = await _productRepository.GetByCategoryAsync(categoryId);
        return Ok(products);
    }

    [HttpGet("search")]
    public async Task<ActionResult<IEnumerable<Product>>> Search([FromQuery] string term)
    {
        var products = await _productRepository.SearchAsync(term);
        return Ok(products);
    }

    [HttpPost]
    public async Task<ActionResult<Product>> CreateProduct(Product product)
    {
        var created = await _productRepository.AddAsync(product);
        return CreatedAtAction(nameof(GetProduct), new { id = created.Id }, created);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateProduct(int id, Product product)
    {
        if (id != product.Id) return BadRequest();
        await _productRepository.UpdateAsync(product);
        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteProduct(int id)
    {
        await _productRepository.DeleteAsync(id);
        return NoContent();
    }
}
OnlineStore.API/Controllers/CategoriesController.cs
using Microsoft.AspNetCore.Mvc;
using OnlineStore.Core.Entities;
using OnlineStore.Core.Interfaces;

namespace OnlineStore.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class CategoriesController : ControllerBase
{
    private readonly IRepository<Category> _categoryRepository;

    public CategoriesController(IRepository<Category> categoryRepository)
    {
        _categoryRepository = categoryRepository;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Category>>> GetCategories()
    {
        var categories = await _categoryRepository.GetAllAsync();
        return Ok(categories);
    }
}
Step 1.8: Configure Program.cs (OnlineStore.API)
OnlineStore.API/Program.cs
using Microsoft.EntityFrameworkCore;
using OnlineStore.Core.Interfaces;
using OnlineStore.Infrastructure.Data;
using OnlineStore.Infrastructure.Repositories;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Database connection
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<StoreDbContext>(options =>
    options.UseMySql(connectionString, ServerVersion.AutoDetect(connectionString)));

// Register repositories
builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));
builder.Services.AddScoped<IProductRepository, ProductRepository>();

// CORS for React frontend
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowReact", policy =>
    {
        policy.WithOrigins("http://localhost:5173", "http://localhost:3000")
              .AllowAnyHeader()
              .AllowAnyMethod();
    });
});

var app = builder.Build();

// Configure pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseCors("AllowReact");
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();
Step 1.9: Configure Database Connection
OnlineStore.API/appsettings.json
{
  "ConnectionStrings": {
    "DefaultConnection": "server=localhost;port=3306;database=onlinestore;user=root;password=yourpassword"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
Step 1.10: Create and Run Migrations
# Install EF Core tools globally
dotnet tool install --global dotnet-ef

# Navigate to API project
cd OnlineStore.API

# Create initial migration
dotnet ef migrations add InitialCreate --project ../OnlineStore.Infrastructure --startup-project .

# Update database
dotnet ef database update --project ../OnlineStore.Infrastructure --startup-project .

# Run the API
dotnet run
üéì Learning Checkpoint: You've learned:
‚Ä¢	Clean Architecture with separation of concerns
‚Ä¢	Entity Framework Core with MySQL
‚Ä¢	Repository pattern
‚Ä¢	Async/await patterns
‚Ä¢	RESTful API design
________________________________________
üìö Phase 2: Frontend with Modern React
Step 2.1: Create React Project with Vite
# Create React app with Vite
npm create vite@latest online-store-frontend -- --template react

cd online-store-frontend
npm install

# Install dependencies
npm install react-router-dom @tanstack/react-query axios
npm install -D tailwindcss postcss autoprefixer
	--> check the end of this file!
npx tailwindcss init -p
Step 2.2: Configure Tailwind CSS
tailwind.config.js
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;
Step 2.3: Create API Service Layer
src/services/api.js
import axios from 'axios';

const API_BASE_URL = 'http://localhost:5000/api';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

export const productsAPI = {
  getAll: () => api.get('/products'),
  getById: (id) => api.get(`/products/${id}`),
  getByCategory: (categoryId) => api.get(`/products/category/${categoryId}`),
  search: (term) => api.get(`/products/search?term=${term}`),
  create: (product) => api.post('/products', product),
  update: (id, product) => api.put(`/products/${id}`, product),
  delete: (id) => api.delete(`/products/${id}`),
};

export const categoriesAPI = {
  getAll: () => api.get('/categories'),
};

export default api;
Step 2.4: Create Shopping Cart Context
src/context/CartContext.jsx
import { createContext, useContext, useReducer, useEffect } from 'react';

const CartContext = createContext();

const cartReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_ITEM': {
      const existingItem = state.items.find(item => item.id === action.payload.id);
      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =>
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          ),
        };
      }
      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }],
      };
    }
    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload),
      };
    case 'UPDATE_QUANTITY':
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.payload.id
            ? { ...item, quantity: action.payload.quantity }
            : item
        ),
      };
    case 'CLEAR_CART':
      return { ...state, items: [] };
    default:
      return state;
  }
};

export const CartProvider = ({ children }) => {
  const [state, dispatch] = useReducer(cartReducer, { items: [] }, (initial) => {
    const saved = localStorage.getItem('cart');
    return saved ? JSON.parse(saved) : initial;
  });

  useEffect(() => {
    localStorage.setItem('cart', JSON.stringify(state));
  }, [state]);

  const addItem = (product) => dispatch({ type: 'ADD_ITEM', payload: product });
  const removeItem = (id) => dispatch({ type: 'REMOVE_ITEM', payload: id });
  const updateQuantity = (id, quantity) => dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } });
  const clearCart = () => dispatch({ type: 'CLEAR_CART' });

  const total = state.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  const itemCount = state.items.reduce((sum, item) => sum + item.quantity, 0);

  return (
    <CartContext.Provider value={{ items: state.items, addItem, removeItem, updateQuantity, clearCart, total, itemCount }}>
      {children}
    </CartContext.Provider>
  );
};

export const useCart = () => {
  const context = useContext(CartContext);
  if (!context) throw new Error('useCart must be used within CartProvider');
  return context;
};
Step 2.5: Create React Components
src/components/ProductCard.jsx
import { useCart } from '../context/CartContext';

export default function ProductCard({ product }) {
  const { addItem } = useCart();

  return (
    <div className="bg-white rounded-lg shadow-md overflow-hidden hover:shadow-xl transition-shadow">
      <img
        src={product.imageUrl}
        alt={product.name}
        className="w-full h-48 object-cover"
      />
      <div className="p-4">
        <h3 className="text-lg font-semibold text-gray-800">{product.name}</h3>
        <p className="text-sm text-gray-600 mt-1">{product.description}</p>
        <div className="mt-4 flex items-center justify-between">
          <span className="text-2xl font-bold text-blue-600">
            ${product.price.toFixed(2)}
          </span>
          <button
            onClick={() => addItem(product)}
            className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors"
          >
            Add to Cart
          </button>
        </div>
        <p className="text-sm text-gray-500 mt-2">Stock: {product.stock}</p>
      </div>
    </div>
  );
}
src/components/Header.jsx
import { Link } from 'react-router-dom';
import { useCart } from '../context/CartContext';

export default function Header() {
  const { itemCount } = useCart();

  return (
    <header className="bg-blue-600 text-white shadow-lg">
      <div className="container mx-auto px-4 py-4">
        <div className="flex items-center justify-between">
          <Link to="/" className="text-2xl font-bold">
            Online Store
          </Link>
          <nav className="flex gap-6 items-center">
            <Link to="/" className="hover:text-blue-200">Products</Link>
            <Link to="/cart" className="hover:text-blue-200 relative">
              Cart
              {itemCount > 0 && (
                <span className="absolute -top-2 -right-2 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                  {itemCount}
                </span>
              )}
            </Link>
          </nav>
        </div>
      </div>
    </header>
  );
}
Step 2.6: Create Pages
src/pages/ProductsPage.jsx
import { useQuery } from '@tanstack/react-query';
import { productsAPI, categoriesAPI } from '../services/api';
import ProductCard from '../components/ProductCard';
import { useState } from 'react';

export default function ProductsPage() {
  const [selectedCategory, setSelectedCategory] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');

  const { data: products, isLoading: productsLoading } = useQuery({
    queryKey: ['products', selectedCategory],
    queryFn: () =>
      selectedCategory
        ? productsAPI.getByCategory(selectedCategory).then(res => res.data)
        : productsAPI.getAll().then(res => res.data),
  });

  const { data: categories } = useQuery({
    queryKey: ['categories'],
    queryFn: () => categoriesAPI.getAll().then(res => res.data),
  });

  const filteredProducts = products?.filter(p =>
    p.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  if (productsLoading) return <div className="text-center py-8">Loading...</div>;

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <input
          type="text"
          placeholder="Search products..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full max-w-md px-4 py-2 border rounded-lg"
        />
      </div>

      <div className="flex gap-4 mb-6">
        <button
          onClick={() => setSelectedCategory(null)}
          className={`px-4 py-2 rounded-lg ${!selectedCategory ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
        >
          All
        </button>
        {categories?.map(cat => (
          <button
            key={cat.id}
            onClick={() => setSelectedCategory(cat.id)}
            className={`px-4 py-2 rounded-lg ${selectedCategory === cat.id ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}
          >
            {cat.name}
          </button>
        ))}
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
        {filteredProducts?.map(product => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  );
}
src/pages/CartPage.jsx
import { useCart } from '../context/CartContext';
import { Link } from 'react-router-dom';

export default function CartPage() {
  const { items, removeItem, updateQuantity, total, clearCart } = useCart();

  if (items.length === 0) {
    return (
      <div className="container mx-auto px-4 py-16 text-center">
        <h2 className="text-2xl font-bold mb-4">Your cart is empty</h2>
        <Link to="/" className="text-blue-600 hover:underline">
          Continue Shopping
        </Link>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Shopping Cart</h1>
      
      <div className="bg-white rounded-lg shadow-md p-6">
        {items.map(item => (
          <div key={item.id} className="flex items-center gap-4 py-4 border-b">
            <img src={item.imageUrl} alt={item.name} className="w-20 h-20 object-cover rounded" />
            <div className="flex-1">
              <h3 className="font-semibold">{item.name}</h3>
              <p className="text-gray-600">${item.price.toFixed(2)}</p>
            </div>
            <input
              type="number"
              min="1"
              value={item.quantity}
              onChange={(e) => updateQuantity(item.id, parseInt(e.target.value))}
              className="w-20 px-2 py-1 border rounded"
            />
            <button
              onClick={() => removeItem(item.id)}
              className="text-red-600 hover:text-red-800"
            >
              Remove
            </button>
          </div>
        ))}
        
        <div className="mt-6 flex justify-between items-center">
          <button
            onClick={clearCart}
            className="text-gray-600 hover:text-gray-800"
          >
            Clear Cart
          </button>
          <div className="text-right">
            <p className="text-2xl font-bold">Total: ${total.toFixed(2)}</p>
            <button className="mt-4 bg-blue-600 text-white px-8 py-3 rounded-lg hover:bg-blue-700">
              Checkout
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
Step 2.7: Setup App Router
src/App.jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { CartProvider } from './context/CartContext';
import Header from './components/Header';
import ProductsPage from './pages/ProductsPage';
import CartPage from './pages/CartPage';

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <CartProvider>
        <BrowserRouter>
          <div className="min-h-screen bg-gray-50">
            <Header />
            <Routes>
              <Route path="/" element={<ProductsPage />} />
              <Route path="/cart" element={<CartPage />} />
            </Routes>
          </div>
        </BrowserRouter>
      </CartProvider>
    </QueryClientProvider>
  );
}

export default App;
Step 2.8: Run the Frontend
npm run dev
üéì Learning Checkpoint: You've learned:
‚Ä¢	Modern React with Vite
‚Ä¢	React Router v6
‚Ä¢	Context API for state management
‚Ä¢	React Query for server state
‚Ä¢	Tailwind CSS for styling
‚Ä¢	Custom hooks pattern
________________________________________
üìö Phase 3: Deploy to Azure
Step 3.1: Prepare Backend for Azure
Add Azure-specific configuration to appsettings.json:
{
  "ConnectionStrings": {
    "DefaultConnection": "server={your-mysql-server}.mysql.database.azure.com;port=3306;database=onlinestore;user={admin-user};password={password};SslMode=Required"
  }
}
Step 3.2: Create Azure Resources
# Install Azure CLI: https://docs.microsoft.com/cli/azure/install-azure-cli

# Login to Azure
az login

# Create resource group
az group create --name online-store-rg --location eastus

# Create Azure Database for MySQL Flexible Server
az mysql flexible-server create \
  --resource-group online-store-rg \
  --name onlinestore-mysql-server \
  --location eastus \
  --admin-user adminuser \
  --admin-password YourPassword123! \
  --sku-name Standard_B1ms \
  --tier Burstable \
  --storage-size 32

# Create database
az mysql flexible-server db create \
  --resource-group online-store-rg \
  --server-name onlinestore-mysql-server \
  --database-name onlinestore

# Configure firewall (allow Azure services)
az mysql flexible-server firewall-rule create \
  --resource-group online-store-rg \
  --name onlinestore-mysql-server \
  --rule-name AllowAzure \
  --start-ip-address 0.0.0.0 \
  --end-ip-address 0.0.0.0
Step 3.3: Deploy .NET API to Azure App Service
# Create App Service Plan
az appservice plan create \
  --name online-store-plan \
  --resource-group online-store-rg \
  --sku B1 \
  --is-linux

# Create Web App for .NET API
az webapp create \
  --resource-group online-store-rg \
  --plan online-store-plan \
  --name onlinestore-api-{your-unique-name} \
  --runtime "DOTNETCORE:8.0"

# Configure connection string as environment variable
az webapp config appsettings set \
  --resource-group online-store-rg \
  --name onlinestore-api-{your-unique-name} \
  --settings ConnectionStrings__DefaultConnection="server=onlinestore-mysql-server.mysql.database.azure.com;port=3306;database=onlinestore;user=adminuser;password=YourPassword123!;SslMode=Required"

# Publish from Visual Studio or CLI
cd OnlineStore.API
dotnet publish -c Release

# Deploy (install Azure CLI extension first)
az webapp up \
  --resource-group online-store-rg \
  --name onlinestore-api-{your-unique-name} \
  --plan online-store-plan \
  --os-type Linux \
  --runtime "DOTNETCORE:8.0"
Alternative: Deploy via Visual Studio
1.	Right-click on OnlineStore.API project ‚Üí Publish
2.	Choose Azure ‚Üí Azure App Service (Linux)
3.	Select your subscription and create new App Service
4.	Configure connection string in Configuration settings
5.	Click Publish
Step 3.4: Run Migrations on Azure Database
# Update connection string in appsettings.json temporarily
# Or set environment variable
export ConnectionStrings__DefaultConnection="server=onlinestore-mysql-server.mysql.database.azure.com;port=3306;database=onlinestore;user=adminuser;password=YourPassword123!;SslMode=Required"

# Run migrations
cd OnlineStore.API
dotnet ef database update --project ../OnlineStore.Infrastructure --startup-project .
Step 3.5: Configure CORS for Production
Update Program.cs to allow your Azure frontend domain:
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowReact", policy =>
    {
        policy.WithOrigins(
            "http://localhost:5173", 
            "http://localhost:3000",
            "https://onlinestore-frontend-{your-unique-name}.azurewebsites.net"
        )
        .AllowAnyHeader()
        .AllowAnyMethod();
    });
});
Step 3.6: Deploy React Frontend to Azure Static Web Apps
# Build the React app
cd online-store-frontend
npm run build

# Create Azure Static Web App
az staticwebapp create \
  --name onlinestore-frontend \
  --resource-group online-store-rg \
  --source . \
  --location "eastus" \
  --branch main \
  --app-location "/" \
  --output-location "dist"
Alternative: Deploy via GitHub Actions (Recommended)
1.	Push your React code to GitHub
2.	In Azure Portal, create a Static Web App
3.	Connect to your GitHub repository
4.	Azure automatically creates a GitHub Actions workflow
5.	Configure build settings: 
o	App location: /
o	API location: (leave empty)
o	Output location: dist
Step 3.7: Update React API Configuration for Production
Create environment files:
online-store-frontend/.env.development
VITE_API_URL=http://localhost:5000/api
online-store-frontend/.env.production
VITE_API_URL=https://onlinestore-api-{your-unique-name}.azurewebsites.net/api
Update src/services/api.js:
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:5000/api';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add request interceptor for debugging
api.interceptors.request.use(
  config => {
    console.log('API Request:', config.method.toUpperCase(), config.url);
    return config;
  },
  error => Promise.reject(error)
);

// Add response interceptor for error handling
api.interceptors.response.use(
  response => response,
  error => {
    console.error('API Error:', error.response?.status, error.message);
    return Promise.reject(error);
  }
);

export const productsAPI = {
  getAll: () => api.get('/products'),
  getById: (id) => api.get(`/products/${id}`),
  getByCategory: (categoryId) => api.get(`/products/category/${categoryId}`),
  search: (term) => api.get(`/products/search?term=${term}`),
  create: (product) => api.post('/products', product),
  update: (id, product) => api.put(`/products/${id}`, product),
  delete: (id) => api.delete(`/products/${id}`),
};

export const categoriesAPI = {
  getAll: () => api.get('/categories'),
};

export default api;
Step 3.8: Configure Azure Static Web App Configuration
online-store-frontend/staticwebapp.config.json
{
  "navigationFallback": {
    "rewrite": "/index.html",
    "exclude": ["/images/*.{png,jpg,gif}", "/css/*"]
  },
  "routes": [
    {
      "route": "/api/*",
      "allowedRoles": ["anonymous"]
    }
  ],
  "responseOverrides": {
    "404": {
      "rewrite": "/index.html",
      "statusCode": 200
    }
  }
}
Step 3.9: Monitor and Debug in Azure
Enable Application Insights for .NET API:
# Add Application Insights
az monitor app-insights component create \
  --app onlinestore-insights \
  --location eastus \
  --resource-group online-store-rg \
  --application-type web

# Get instrumentation key
az monitor app-insights component show \
  --app onlinestore-insights \
  --resource-group online-store-rg \
  --query instrumentationKey

# Add to your API
dotnet add package Microsoft.ApplicationInsights.AspNetCore
Update Program.cs:
builder.Services.AddApplicationInsightsTelemetry();
View logs:
# Stream logs from App Service
az webapp log tail \
  --resource-group online-store-rg \
  --name onlinestore-api-{your-unique-name}
Step 3.10: Set Up CI/CD Pipeline
GitHub Actions for .NET API (.github/workflows/deploy-api.yml):
name: Deploy API to Azure

on:
  push:
    branches: [ main ]
    paths:
      - 'OnlineStore.API/**'
      - 'OnlineStore.Core/**'
      - 'OnlineStore.Infrastructure/**'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build
      run: dotnet build --configuration Release --no-restore
    
    - name: Publish
      run: dotnet publish OnlineStore.API/OnlineStore.API.csproj -c Release -o ./publish
    
    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: 'onlinestore-api-{your-unique-name}'
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: ./publish
Get publish profile:
az webapp deployment list-publishing-profiles \
  --resource-group online-store-rg \
  --name onlinestore-api-{your-unique-name} \
  --xml
Add this as a GitHub secret named AZURE_WEBAPP_PUBLISH_PROFILE
Step 3.11: Optimize for Production
Add caching to .NET API:
// In Program.cs
builder.Services.AddResponseCaching();
builder.Services.AddMemoryCache();

// In pipeline
app.UseResponseCaching();
Add caching to ProductsController:
[HttpGet]
[ResponseCache(Duration = 300)] // Cache for 5 minutes
public async Task<ActionResult<IEnumerable<Product>>> GetProducts()
{
    var products = await _productRepository.GetAllAsync();
    return Ok(products);
}
Add React Query caching configuration:
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});
Step 3.12: Security Best Practices
Add security headers to .NET API:
app.Use(async (context, next) =>
{
    context.Response.Headers.Add("X-Content-Type-Options", "nosniff");
    context.Response.Headers.Add("X-Frame-Options", "DENY");
    context.Response.Headers.Add("X-XSS-Protection", "1; mode=block");
    context.Response.Headers.Add("Referrer-Policy", "strict-origin-when-cross-origin");
    await next();
});
Add rate limiting:
dotnet add package AspNetCoreRateLimit
builder.Services.AddMemoryCache();
builder.Services.Configure<IpRateLimitOptions>(builder.Configuration.GetSection("IpRateLimiting"));
builder.Services.AddInMemoryRateLimiting();
builder.Services.AddSingleton<IRateLimitConfiguration, RateLimitConfiguration>();

app.UseIpRateLimiting();
üéì Learning Checkpoint: You've learned:
‚Ä¢	Azure App Service deployment
‚Ä¢	Azure Database for MySQL configuration
‚Ä¢	Azure Static Web Apps
‚Ä¢	CI/CD with GitHub Actions
‚Ä¢	Environment configuration
‚Ä¢	Production optimizations
‚Ä¢	Security best practices
________________________________________
üìö Phase 4: Advanced Features
Step 4.1: Add Authentication with JWT
Install packages:
cd OnlineStore.API
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
dotnet add package System.IdentityModel.Tokens.Jwt
Create User entity and authentication service Add image upload with Azure Blob Storage Implement order processing Add email notifications Set up automated testing
Step 4.2: Performance Optimization
Backend optimizations:
‚Ä¢	Implement pagination
‚Ä¢	Add database indexing
‚Ä¢	Use DTOs to reduce payload size
‚Ä¢	Implement Redis caching
Frontend optimizations:
‚Ä¢	Code splitting with React.lazy
‚Ä¢	Image optimization
‚Ä¢	Service Worker for PWA
‚Ä¢	Implement virtual scrolling
Step 4.3: Monitoring and Analytics
Set up:
‚Ä¢	Azure Application Insights
‚Ä¢	Custom telemetry
‚Ä¢	User behavior analytics
‚Ä¢	Performance monitoring
‚Ä¢	Error tracking
________________________________________
üéØ Testing Your Application
Backend Testing
cd OnlineStore.API
dotnet test
Frontend Testing
cd online-store-frontend
npm test
Load Testing with Azure
az load create \
  --name onlinestore-load-test \
  --resource-group online-store-rg
________________________________________
üìã Checklist for Completion
Backend ‚úì
‚Ä¢	[ ] .NET 8 Web API created
‚Ä¢	[ ] Entity Framework Core configured
‚Ä¢	[ ] MySQL database connected
‚Ä¢	[ ] Repository pattern implemented
‚Ä¢	[ ] RESTful endpoints working
‚Ä¢	[ ] Swagger documentation available
‚Ä¢	[ ] CORS configured
‚Ä¢	[ ] Deployed to Azure App Service
Frontend ‚úì
‚Ä¢	[ ] React app with Vite created
‚Ä¢	[ ] React Router configured
‚Ä¢	[ ] Context API for cart management
‚Ä¢	[ ] React Query for server state
‚Ä¢	[ ] Tailwind CSS styling
‚Ä¢	[ ] Responsive design
‚Ä¢	[ ] Deployed to Azure Static Web Apps
DevOps ‚úì
‚Ä¢	[ ] CI/CD pipeline configured
‚Ä¢	[ ] Environment variables set
‚Ä¢	[ ] Database migrations automated
‚Ä¢	[ ] Monitoring enabled
‚Ä¢	[ ] Security headers configured
________________________________________
üöÄ Next Steps
1.	Add user authentication - Implement JWT-based auth with user registration/login
2.	Payment integration - Add Stripe or PayPal for checkout
3.	Admin dashboard - Create separate admin interface for managing products
4.	Email notifications - Send order confirmations using SendGrid
5.	Search enhancement - Implement full-text search with Azure Cognitive Search
6.	Mobile app - Create React Native version
7.	Microservices - Break into separate services (Products, Orders, Users)
________________________________________
üìö Resources
Documentation
‚Ä¢	.NET Documentation
‚Ä¢	React Documentation
‚Ä¢	Azure Documentation
‚Ä¢	Entity Framework Core
‚Ä¢	React Query
Tutorials
‚Ä¢	Clean Architecture in .NET
‚Ä¢	React Patterns
‚Ä¢	Azure App Service
Tools
‚Ä¢	Azure Portal
‚Ä¢	Postman - API testing
‚Ä¢	React DevTools
________________________________________
üêõ Common Issues and Solutions
Issue: Database connection fails
Solution: Check connection string, ensure firewall rules allow your IP, verify SSL mode
Issue: CORS errors in production
Solution: Update CORS policy with production frontend URL, redeploy API
Issue: React build fails
Solution: Check environment variables, ensure all dependencies installed, clear node_modules and reinstall
Issue: Azure deployment timeout
Solution: Increase deployment timeout in Azure Portal, check application logs
________________________________________
üí° Key Concepts Learned
React Modern Patterns
‚Ä¢	Custom Hooks - Reusable logic extraction
‚Ä¢	Context API - Global state without prop drilling
‚Ä¢	React Query - Server state management with caching
‚Ä¢	Code Organization - Feature-based folder structure
.NET Best Practices
‚Ä¢	Clean Architecture - Separation of concerns
‚Ä¢	Repository Pattern - Data access abstraction
‚Ä¢	Dependency Injection - Loose coupling
‚Ä¢	Async/Await - Non-blocking operations
Azure Cloud Services
‚Ä¢	App Service - Managed hosting platform
‚Ä¢	Static Web Apps - Modern web app hosting
‚Ä¢	Database for MySQL - Managed database service
‚Ä¢	CI/CD - Automated deployments
________________________________________
üéâ Congratulations! You've built a complete full-stack e-commerce application using modern technologies and deployed it to Azure. This foundation will serve you well for building production-ready applications.



npx tailwindcss init -p fails because the version you installed (tailwindcss@4.1.17 in package.json:23) no longer
  ships the CLI binary that npx tries to execute. If you inspect node_modules/tailwindcss/package.json, you‚Äôll notice
  there‚Äôs no "bin" entry at all, so npx can‚Äôt ‚Äúdetermine executable to run‚Äù and exits with that exact error. Tailwind
  CSS 4 has moved away from the old PostCSS-based setup, so the Vite/Tailwind 3 instructions (run npx tailwindcss init
  -p, edit tailwind.config.js, etc.) no longer apply.

  You have two viable options:

  1. Stick with the familiar Tailwind 3 workflow.

     npm uninstall tailwindcss
     npm install -D tailwindcss@^3.4 postcss autoprefixer
     npx tailwindcss init -p
     That restores the CLI binary and the init -p command will generate the config files you expect.
     That restores the CLI binary and the init -p command will generate the config files you expect.
  2. Stay on Tailwind 4, but follow the new setup.
     Tailwind 4 uses the ‚Äúoxide‚Äù compiler and an inline config approach, so there‚Äôs no tailwindcss init. Instead you
     import tailwindcss directly in your CSS and configure it via the new @config directive (see the v4 docs). If you
     go this route you can uninstall postcss/autoprefixer, since they aren‚Äôt required anymore, and wire Tailwind through
     Vite‚Äôs PostCSS pipeline or the dedicated Tailwind CLI.

  Pick the path that matches the docs/tutorial you‚Äôre following‚Äîmost current guides (and Vite‚Äôs template) still assume
  Tailwind 3, so downgrading is usually the quickest fix. After adjusting the dependency, rerun the npx tailwindcss init
  -p command and it will succeed.